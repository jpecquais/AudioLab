import numpy as np
import scipy.signal as signal
import soundfile as sf 
import matplotlib.pyplot as plt
import audio_dspy as adsp
from typing import List
import pathlib

path_to_ir = pathlib.Path(__file__).parent.parent / "audio/final_IR_1024.wav"
impulse, sample_rate = sf.read(path_to_ir)

# lambda_ = 0.15
lambda_ = 0.75
iir_order = 64

def add_missing_complex_conjugate(array: np.ndarray):
    list = array.tolist()
    for cnum in list:
        if not np.conj(cnum) in list:
            list.insert(list.index(cnum)+1,np.conj(cnum))
    return np.array(list)

def crossover(order:int, fc: float, fs: float = 48000, output: str = 'sos'):
    if order % 2 != 0: return
    low_pass = []
    high_pass = []
    for n in range(2):
        new_lowpass = signal.butter(order//2,fc,'lowpass',fs=fs, output=output)[0].tolist()
        low_pass.append(new_lowpass)
        high_pass.append(signal.butter(order//2,fc,'highpass',fs=fs, output=output)[0].tolist())
    return low_pass,high_pass

def iir_to_fir(order,lambda_,impulse):
    # Prony's method to approximate the impulse response
    # Adjust `a_order` and `b_order` as needed
    a_order = order  # Denominator polynomial order (related to the number of biquad sections)
    b_order = order # Numerator polynomial order

    h_warped = adsp.allpass_warp(lambda_,impulse)
    bwp, awp = adsp.prony(h_warped, b_order, a_order)
    zwp = np.roots(bwp)
    pwp = np.roots(awp)
    z = (zwp+lambda_)/(1+lambda_*zwp)
    p = (pwp+lambda_)/(1+lambda_*pwp)
    k=0.5
    # Convert the filter into a series of second-order sections for stability
    return z,p,k#signal.zpk2sos(z,p,k)

def sos_to_faust_tf22t(sos_array, faust_process_name="process"):
    """
    Converts a SciPy SOS array to a Faust DSP script using cascaded tf22t biquads.

    Assumes the input sos_array is generated by SciPy functions and
    has a0 = 1 for all sections.

    Args:
        sos_array (numpy.ndarray): Array of second-order sections,
                                   shape (n_sections, 6). Each row is
                                   [b0, b1, b2, a0, a1, a2].
        faust_process_name (str): The name for the main Faust process line.
                                  Defaults to "process".

    Returns:
        str: A string containing the generated Faust code.

    Raises:
        ValueError: If the input array does not have 6 columns or is not 2D.
    """
    if not isinstance(sos_array, np.ndarray):
        # Attempt to convert lists/tuples of lists/tuples to numpy array
        try:
            sos_array = np.array(sos_array, dtype=float)
        except Exception as e:
            raise ValueError(f"Input could not be converted to a NumPy array: {e}")

    if sos_array.ndim != 2 or sos_array.shape[1] != 6:
        raise ValueError(f"Input sos_array must be a 2D array with 6 columns, got shape {sos_array.shape}")

    n_sections = sos_array.shape[0]

    if n_sections == 0:
        # Handle empty array - return a simple pass-through Faust process
        faust_code = f'''
import("stdfaust.lib");
{faust_process_name} = _; // Pass-through for empty filter
'''
        return faust_code.strip()

    biquad_strings = []
    for i, section in enumerate(sos_array):
        b0, b1, b2, a0, a1, a2 = section

        # Check if a0 is indeed close to 1, as expected
        if not np.isclose(a0, 1.0):
            print(f"Warning: Section {i} has a0 = {a0:.8g} which is not close to 1. "
                  "Proceeding according to tf22t definition (ignores a0).")

        # Format the coefficients for Faust. Using '.16g' preserves precision
        # and provides a reasonably compact representation.
        # tf22t(b0, b1, b2, a1, a2)
        biquad_str = f"fi.tf22t({b0:.16g}, {b1:.16g}, {b2:.16g}, {a1:.16g}, {a2:.16g})"
        biquad_strings.append(biquad_str)

    # Join the biquad strings with the Faust series composition operator ':'
    faust_filter_chain = " : ".join(biquad_strings)

    # Construct the full Faust code
    faust_code = f'''
import("stdfaust.lib");

{faust_process_name} = {faust_filter_chain};
'''
    return faust_code.strip() # Remove leading/trailing whitespace

impulse_for_fir = impulse#np.concatenate([impulse[:fir_order],np.zeros(len(impulse)-fir_order)])
impulse_for_iir = impulse#np.concatenate([np.zeros(fir_order),impulse[fir_order:]])
zpk_prony = iir_to_fir(iir_order,lambda_,impulse_for_iir)

sos_lowpass, sos_highpass = crossover(8,2000,fs=sample_rate)

prony = signal.zpk2sos(zpk_prony[0],zpk_prony[1],zpk_prony[2])
print(prony)

# iir_hybrid = signal.zpk2sos(zpk_hybrid[0],zpk_hybrid[1],zpk_hybrid[2])

# Calculate the frequency response of the original impulse response
w_h, h_freq = signal.freqz(impulse, fs=sample_rate, worN=8192)

# Calculate the frequency response of the IIR filter
w_iir, h_prony = signal.sosfreqz(prony, fs=sample_rate, worN=8192)

h_freq = h_freq/max(h_freq)
h_prony = h_prony/max(h_prony)

h_db_prony_error = np.abs(20 * np.log10(abs(h_prony)/h_freq))

cumulated_error2 = np.std(h_db_prony_error)

dirac = np.zeros(1024)
dirac[0] = 1
prony_impulse = signal.sosfilt(prony,dirac)
w_hybrid, h_hybrid = signal.freqz(impulse_for_fir+prony_impulse, fs=sample_rate, worN=8192)
h_hybrid = h_hybrid/max(h_hybrid)
# sf.write("prony_impulse.wav",prony_impulse,sample_rate)

# Plot both frequency responses on the same plot
fig, axs = plt.subplots()
# axs[0].figure(figsize=(10, 6))
axs.semilogx(w_h, 20 * np.log10(abs(h_freq)), label='Original Impulse Response')
axs.semilogx(w_h, 20 * np.log10(abs(h_hybrid)), label='IIR Filter (Prony)', linestyle='--')
axs.set_title('Frequency Response Comparison')
axs.set_xlim(80,20000)
axs.set_xlabel('Frequency')
axs.set_ylabel('Magnitude (dB)')
axs.grid(True)
axs.legend()

plt.show()

output_path = pathlib.Path(__file__).parent.parent / "dsp/iir-speaker.dsp"
with output_path.open('w') as file:
    # Write content to the file
    faust_code = sos_to_faust_tf22t(prony)
    file.write(faust_code)